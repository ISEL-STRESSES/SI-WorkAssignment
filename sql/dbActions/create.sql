BEGIN TRANSACTION;
-- Model
-- Create domain
CREATE DOMAIN ALPHANUMERIC AS VARCHAR(10) CHECK (VALUE ~* '^[A-Z0-9]+$');
CREATE DOMAIN URL AS VARCHAR(255) CHECK (VALUE ~* '^(http|https)://[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(/\S*)?$');
CREATE DOMAIN email AS varchar(254) CHECK (VALUE ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z]{2,}$');

-- Create table
-- Região
CREATE TABLE IF NOT EXISTS regiao(
    nome VARCHAR(50) PRIMARY KEY
);

-- Jogador
CREATE TABLE IF NOT EXISTS jogador(
    id          INT         PRIMARY KEY
        GENERATED BY DEFAULT AS IDENTITY,
    username    VARCHAR(50) NOT NULL,
    email       EMAIL       NOT NULL,
    estado      VARCHAR(20) DEFAULT 'Ativo',
    nome_regiao VARCHAR(50) NOT NULL REFERENCES regiao(nome),

    UNIQUE(username),
    UNIQUE(email),
    UNIQUE(username, email),

    CONSTRAINT estado_jogador CHECK(estado ~* '^(ativo|banido|inativo)$')
);

-- Jogo
CREATE TABLE IF NOT EXISTS jogo(
    id   ALPHANUMERIC PRIMARY KEY,
    nome VARCHAR(50)  NOT NULL,
    url  URL          NOT NULL,

    UNIQUE(nome)
);

-- Conversa
CREATE TABLE IF NOT EXISTS conversa
(
    id   INT         PRIMARY KEY
        GENERATED BY DEFAULT AS IDENTITY,
    nome VARCHAR(50) NOT NULL
);

-- Jogador Estatistica
CREATE TABLE IF NOT EXISTS jogador_estatistica(
    id_jogador   INT PRIMARY KEY REFERENCES jogador(id) ON DELETE CASCADE,
    nr_partidas  INT DEFAULT 0,
    nr_jogos     INT DEFAULT 0,
    total_pontos INT DEFAULT 0
);

-- Jogo Estatistica
CREATE TABLE IF NOT EXISTS jogo_estatistica(
    id_jogo      ALPHANUMERIC PRIMARY KEY REFERENCES jogo(id) ON DELETE CASCADE,
    nr_partidas  INT NOT NULL DEFAULT 0,
    nr_jogadores INT NOT NULL DEFAULT 0,
    total_pontos INT NOT NULL DEFAULT 0
);

-- Partida
CREATE TABLE IF NOT EXISTS partida(
    nr          INT          NOT NULL,
    id_jogo     ALPHANUMERIC NOT NULL REFERENCES jogo(id) ON DELETE CASCADE,
    data_inicio DATE         NOT NULL,
    data_fim    DATE,
    nome_regiao VARCHAR(50)  NOT NULL REFERENCES regiao(nome),

    UNIQUE (id_jogo, nr),

    CONSTRAINT date_constraint CHECK(data_inicio < data_fim),

    CONSTRAINT pk_partida PRIMARY KEY(id_jogo, nr) --INCLUDE (nr)
);


-- Partida normal
CREATE TABLE IF NOT EXISTS partida_normal(
    id_jogo     ALPHANUMERIC NOT NULL,
    nr_partida  INT          NOT NULL,
    dificuldade INT          NOT NULL,
    pontuacao   INT          DEFAULT 0,

    UNIQUE(id_jogo, nr_partida),

    CONSTRAINT dificuldade_constraint CHECK(dificuldade BETWEEN 1 and 5),

    CONSTRAINT fk_partida_normal FOREIGN KEY(id_jogo, nr_partida) REFERENCES partida(id_jogo, nr) ON DELETE CASCADE,
    CONSTRAINT pk_partida_normal PRIMARY KEY(id_jogo, nr_partida)
);

-- Partida multijogador
CREATE TABLE IF NOT EXISTS partida_multijogador(
    id_jogo    ALPHANUMERIC NOT NULL,
    nr_partida INT          NOT NULL,
    estado     VARCHAR(20)  DEFAULT 'Por iniciar',
    pontuacao  INT          DEFAULT 0,

    CONSTRAINT estado_constraint CHECK(estado in ('Por iniciar', 'A aguardar jogadores', 'Em curso', 'Terminada')),

    CONSTRAINT fk_partida_multijogador FOREIGN KEY(id_jogo, nr_partida) REFERENCES partida(id_jogo, nr) ON DELETE CASCADE,
    CONSTRAINT pk_partida_multijogador PRIMARY KEY(nr_partida, id_jogo)
);

-- Cracha
CREATE TABLE IF NOT EXISTS cracha(
    nome          VARCHAR(50)  NOT NULL,
    id_jogo       ALPHANUMERIC NOT NULL REFERENCES jogo(id) ON DELETE CASCADE,
    imagem        URL          NOT NULL,
    limite_pontos INT          NOT NULL,

    UNIQUE (id_jogo, nome),

    CONSTRAINT pk_cracha PRIMARY KEY(nome, id_jogo)
);

-- Mensagem
CREATE TABLE IF NOT EXISTS mensagem(
    nr_ordem    INT  NOT NULL,
    id_jogador  INT  NOT NULL REFERENCES jogador(id),
    id_conversa INT  NOT NULL REFERENCES conversa(id) ON DELETE CASCADE,
    texto       TEXT NOT NULL,
    data        DATE NOT NULL,

    UNIQUE(nr_ordem, id_jogador, id_conversa),

    CONSTRAINT pk_mensagem PRIMARY KEY(nr_ordem, id_jogador, id_conversa)
);

-- Compra (Jogador - Jogo)
CREATE TABLE IF NOT EXISTS compra(
    id_jogador INT             NOT NULL REFERENCES jogador(id),
    id_jogo    ALPHANUMERIC    NOT NULL REFERENCES jogo(id),
    data       DATE            NOT NULL,
    preco      MONEY DEFAULT 0 NOT NULL,

    UNIQUE(id_jogador, id_jogo),

    CONSTRAINT pk_compra PRIMARY KEY(id_jogador, id_jogo)
);

-- Joga (Jogador - Partida)
CREATE TABLE IF NOT EXISTS joga(
    id_jogador INT          NOT NULL REFERENCES jogador(id),
    nr_partida INT          NOT NULL,
    id_jogo    ALPHANUMERIC NOT NULL,

    CONSTRAINT fk_joga_partida FOREIGN KEY(id_jogo, nr_partida) REFERENCES partida(id_jogo, nr) ON DELETE CASCADE,
    CONSTRAINT pk_joga PRIMARY KEY(id_jogador, nr_partida, id_jogo)
);

-- Ganha (Jogador - Cracha)
CREATE TABLE IF NOT EXISTS ganha(
    id_jogador  INT          NOT NULL REFERENCES jogador(id) ON DELETE CASCADE,
    nome_cracha VARCHAR(50)  NOT NULL,
    id_jogo     ALPHANUMERIC NOT NULL,

    UNIQUE(id_jogador, nome_cracha, id_jogo),

    CONSTRAINT fk_ganha_cracha FOREIGN KEY(nome_cracha, id_jogo) REFERENCES cracha(nome, id_jogo) ON DELETE CASCADE,
    CONSTRAINT pk_ganha PRIMARY KEY(id_jogador, nome_cracha, id_jogo)
);

-- Participa (Jogador - Conversa)
CREATE TABLE IF NOT EXISTS participa(
    id_jogador  INT NOT NULL REFERENCES jogador(id)  ON DELETE CASCADE,
    id_conversa INT NOT NULL REFERENCES conversa(id) ON DELETE CASCADE,

    CONSTRAINT pk_participa PRIMARY KEY(id_jogador, id_conversa)
);

-- Amigo
CREATE TABLE IF NOT EXISTS amigo(
    id_jogador1 INT NOT NULL REFERENCES jogador(id) ON DELETE CASCADE,
    id_jogador2 INT NOT NULL REFERENCES jogador(id) ON DELETE CASCADE,

    CONSTRAINT pk_amigo PRIMARY KEY(id_jogador1, id_jogador2)
);

COMMIT;

------------------------------------------------------------------------------------------------------------------------
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- RESTRICOES
-- Model Restrictions
-- 1. The partida must be played by jogadores of the same regiao
-- This function is called before inserting a new row in the joga table and checks if the jogador is from the same
-- regiao as the partida he is playing in.
--
-- Example Usage:
-- INSERT INTO partida VALUES ( now(), null, 1000000000, 'Portugal');
-- INSERT INTO joga (id_jogador, nr_partida) VALUES (1, 1);
CREATE FUNCTION checkJogadorPartidaRegiao()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
    DECLARE
        regiao_nome VARCHAR(50);
    BEGIN
        SELECT partida.nome_regiao INTO regiao_nome FROM partida WHERE partida.nr == NEW.nr_partida;
        IF (regiao_nome != (SELECT jogador.nome_regiao FROM jogador WHERE jogador.id == NEW.id_jogador)) THEN
            RAISE EXCEPTION 'O jogador nao pertence a regiao da partida';
        END IF;
    END;
$$;

-- This trigger calls the function checkJogadorPartidaRegiao() before inserting a new row in the joga table
CREATE TRIGGER checkJogadorPartidaRegiao BEFORE INSERT ON joga
    FOR EACH ROW
    EXECUTE FUNCTION checkJogadorPartidaRegiao();

------------------------------------------------------------------------------------------------------------------------
-- 2. The mensagem must be sent by a jogador of the conversa
-- This function is called before inserting a new row in the mensagem table and checks if the jogador is from the same
-- conversa as the mensagem he is sending.
--
-- Example Usage:
-- INSERT INTO mensagem VALUES (1, 1, 'ola', '2019-12-12 12:12:12');
CREATE FUNCTION checkJogadorMensagemConversa()
    RETURNS trigger
    LANGUAGE plpgsql
AS
$$
    DECLARE
        jogador_id INT;
    BEGIN
        SELECT participa.id_jogador INTO jogador_id FROM participa WHERE(
            participa.id_jogador == NEW.id_jogador AND participa.id_conversa == NEW.id_conversa);
        IF(jogador_id == NULL) THEN
            RAISE EXCEPTION 'O jogador nao pertence a conversa';
        END IF;
    END;
$$;

CREATE TRIGGER checkJogadorMensagemConversa BEFORE INSERT ON mensagem
    FOR EACH ROW
    EXECUTE PROCEDURE checkJogadorMensagemConversa();

COMMIT;

------------------------------------------------------------------------------------------------------------------------
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- Functionalities
-- Jogo
-- 1. Update the nr_partidas of the jogo_estatistica when a new partida is added or removed
CREATE OR REPLACE FUNCTION updateNrPartidas()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
    -- OLD AND NEW is the same id_jogo
    BEGIN
        IF (TG_OP = 'INSERT') THEN
            UPDATE jogo_estatistica
                SET nr_partidas = nr_partidas + 1
                WHERE id_jogo = NEW.id_jogo;
            END IF;
        IF (TG_OP = 'DELETE') THEN
            UPDATE jogo_estatistica
                SET nr_partidas = nr_partidas - 1
                WHERE id_jogo = OLD.id_jogo;
        end if;
        RETURN NEW;
    END;
$$;

CREATE TRIGGER updateNrPartidasTrigger
    AFTER INSERT OR DELETE ON partida
    FOR EACH ROW
    EXECUTE FUNCTION updateNrPartidas();

------------------------------------------------------------------------------------------------------------------------
-- 2. Update the nr_jogadores of the jogo_estatistica when a new jogador is added or removed
CREATE OR REPLACE FUNCTION updateNrJogadores()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
    BEGIN
        UPDATE jogo_estatistica
        SET nr_jogadores = (SELECT COUNT(nr_jogadores) FROM joga WHERE joga.id_jogo = NEW.id_jogo)
        WHERE id_jogo = NEW.id_jogo;
        RETURN NEW;
    END;
$$;

CREATE TRIGGER updateNrJogadoresTrigger
    AFTER INSERT OR DELETE ON joga
    FOR EACH ROW
    EXECUTE FUNCTION updateNrJogadores();

------------------------------------------------------------------------------------------------------------------------
-- 3. Update the total_pontos of the jogo_estatistica when a new partida is added or removed
CREATE OR REPLACE FUNCTION updatePontuacaoTotal()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
    DECLARE
        pontos_normal INT;
        pontos_multijogador INT;
    BEGIN
        SELECT SUM(pontuacao) INTO pontos_normal FROM partida_normal WHERE partida_normal.id_jogo = NEW.id_jogo;
        SELECT SUM(pontuacao) INTO pontos_multijogador FROM partida_multijogador WHERE partida_multijogador.id_jogo = NEW.id_jogo;
        -- not atomic because of multiplayer and single player games
        UPDATE jogo_estatistica
        SET total_pontos = pontos_normal + pontos_multijogador
        WHERE id_jogo = NEW.id_jogo;
        RETURN NEW;
    END;
$$;

CREATE TRIGGER updatePontuacaoTotalTrigger
    AFTER INSERT OR DELETE ON partida_multijogador
    FOR EACH ROW
    EXECUTE FUNCTION updatePontuacaoTotal();

CREATE TRIGGER update_total_pontos_trigger
    AFTER INSERT OR DELETE ON partida_normal
    FOR EACH ROW
    EXECUTE FUNCTION updatePontuacaoTotal();

COMMIT TRANSACTION;
------------------------------------------------------------------------------------------------------------------------
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- EXERCICIOS
--(d) Criar os mecanismos que permitam criar o jogador, dados os seus email e username e regiao, desativar e banir o
-- jogador;

-- This procedure creates a new player given their region name, username, and email. It performs the following tasks:
--
-- Checks if the given region name exists in the regiao table. If not, it inserts a new row with the given region name.
-- Inserts a new row into the jogador table with the given username, email, and region name.
-- Example usage:
-- CALL create_jogador('Regiao A', 'user123', 'user123@example.com');
CREATE PROCEDURE createJogador(regiao_nome VARCHAR(50), new_username VARCHAR(10), new_email EMAIL)
    LANGUAGE plpgsql
AS
$$
    BEGIN
        -- Checks
        IF (regiao_nome NOT IN (SELECT regiao.nome FROM regiao)) THEN
            RAISE EXCEPTION 'No Region with name (%)', regiao_nome
                    USING HINT = 'Check the inserted name or insert a new region';
        END IF;
        IF (new_username IN (SELECT jogador.username FROM jogador)) THEN
            RAISE EXCEPTION 'Player already exists with username (%)', new_username
                    USING HINT = 'Check the inserted username';
        END IF;
        -- expected
        INSERT INTO jogador(username, email, nome_regiao) VALUES (new_username, new_email, regiao_nome);
    END;
$$;

-- This procedure updates the state of a player given their player ID and new state. It performs the following tasks:
--
-- Checks if the given player ID exists in the jogador table. If not, it raises a notice indicating that the player was
-- not found.
-- Checks if the player already has the new state. If so, it raises a notice indicating that the player already has this
-- state.
-- Updates the estado field of the jogador table with the new state for the given player ID.
-- Example usage:
-- CALL update_estado_jogador(1, 'ativo');
CREATE PROCEDURE updateEstadoJogador(id_jogador INT, new_estado VARCHAR(10))
    LANGUAGE plpgsql
AS
$$
    BEGIN
        -- Checks
        IF (id_jogador NOT IN (SELECT jogador.id FROM jogador)) THEN
            RAISE EXCEPTION 'No Player with id (%)', id_jogador
                    USING HINT = 'Check the inserted id';
        END IF;
        IF ((SELECT jogador.estado FROM jogador WHERE jogador.id == id_jogador) == new_estado) THEN
            RAISE EXCEPTION 'Player already has state (%)', new_estado
                    USING HINT = 'Check the inserted state';
        END IF;
        -- expected
        UPDATE jogador SET estado = new_estado WHERE jogador.id = id_jogador;
    END ;
$$;

-- This procedure creates a new player given their region name, username, and email. It is an abstraction with
-- transaction control and it performs the following tasks:
--
-- Sets the transaction isolation level to SERIALIZABLE.
-- Calls the create_jogador procedure.
-- If the create_jogador procedure raises a unique_violation exception, it raises a notice indicating that the player
-- already exists and rolls back the transaction.
-- Example usage:
-- CALL createJogadorTransaction('Regiao A', 'user123', 'user123@gmail.com');
CREATE PROCEDURE createJogadorTransaction(regiao_nome VARCHAR(50), new_username VARCHAR(10), new_email EMAIL)
    LANGUAGE plpgsql
AS
$$
    Declare t1 text;
            t2 text;
            t3 text;
            t4 text;
            t5 text;
    BEGIN
        SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; -- default is READ COMMITTED
        call createJogador(regiao_nome, new_username, new_email);
    EXCEPTION
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS t1 = MESSAGE_TEXT,
                                    t2 = RETURNED_SQLSTATE,
                                    t3 = PG_EXCEPTION_DETAIL,
                                    t4 = PG_EXCEPTION_HINT,
                                    t5 = PG_EXCEPTION_CONTEXT;
            RAISE NOTICE 'MESSAGE_TEXT: %', t1;
            RAISE NOTICE 'SQLSTATE: %', t2;
            RAISE NOTICE 'DETAIL: %', t3;
            RAISE NOTICE 'HINT: %', t4;
            RAISE NOTICE 'CONTEXT: %', t5;
            ROLLBACK;
END;
$$;

-- This procedure updates the state of a player given their player ID and new state. It is an abstraction with
-- transaction control and it performs the following tasks:
--
-- Sets the transaction isolation level to SERIALIZABLE.
-- Calls the update_estado_jogador procedure.
-- If the update_estado_jogador procedure raises a unique_violation exception, it raises a notice indicating that the
-- player already has this state and rolls back the transaction.
-- Example usage:
-- CALL updateEstadoJogadorTransaction(1, 'ativo');
CREATE PROCEDURE updateEstadoJogadorTransaction(id_jogador INT, new_estado VARCHAR(10))
    LANGUAGE plpgsql
AS
$$
    Declare t1 text;
            t2 text;
            t3 text;
            t4 text;
            t5 text;
    BEGIN
        SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; -- default is READ COMMITTED
        call updateEstadoJogador(id_jogador, new_estado);
    EXCEPTION
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS t1 = MESSAGE_TEXT,
                                    t2 = RETURNED_SQLSTATE,
                                    t3 = PG_EXCEPTION_DETAIL,
                                    t4 = PG_EXCEPTION_HINT,
                                    t5 = PG_EXCEPTION_CONTEXT;
            RAISE NOTICE 'MESSAGE_TEXT: %', t1;
            RAISE NOTICE 'SQLSTATE: %', t2;
            RAISE NOTICE 'DETAIL: %', t3;
            RAISE NOTICE 'HINT: %', t4;
            RAISE NOTICE 'CONTEXT: %', t5;
            ROLLBACK;
END;
$$;

------------------------------------------------------------------------------------------------------------------------
-- (e) Criar a função totalPontosJogador que recebe como parâmetro o identificador de um jogador e devolve o número
-- total de pontos obtidos pelo jogador.

-- This function calculates and returns the total points obtained by a player given their player ID. It performs the
-- following tasks:
--
-- Checks if the given player ID exists in the jogador table. If not, it raises a notice indicating that the player was
-- not found.
-- Checks if the player is banned or inactive. If so, it raises a notice indicating that the player is banned or
-- inactive.
-- Checks if the player has played any games. If not, it raises a notice indicating that the player has not played any
-- games.
-- Retrieves the points from the partida_normal and partida_multijogador tables for the player ID.
-- Returns the sum of the points from both tables as the total points for the player.
-- Example usage:
-- SELECT totalPontosJogador(1);
CREATE FUNCTION totalPontosJogador(jogador_id INT)
    RETURNS INT
    LANGUAGE plpgsql
AS
$$
    DECLARE
        partidaNormal       INT;
        partidaMultiJogador INT;
    BEGIN
        -- Checks
        IF(jogador_id NOT IN (SELECT jogador.id FROM jogador)) THEN
            RAISE EXCEPTION 'Jogador with id (%) not found', jogador_id
                    USING HINT = 'Check the inserted id';
        END IF;
        IF ((SELECT jogador.estado FROM jogador WHERE jogador.id == jogador_id) == 'banido' | 'desativado') THEN
            RAISE NOTICE 'Jogador with id (%) is banned or inactive', jogador_id
                    USING HINT = 'Check the inserted id';
        END IF;
        IF ((SELECT joga.id_jogador FROM joga) <> jogador_id) THEN
            RAISE NOTICE 'Jogador with id (%) has not played any games', jogador_id
                    USING HINT = 'Check the inserted id or start a new game';
        END IF;
        -- expected
        -- points from partida normal
        SELECT pontuacao FROM partida_normal WHERE (nr_partida == (
        SELECT partida.nr FROM partida WHERE (
        SELECT joga.nr_partida FROM joga WHERE (joga.id_jogador == jogador_id)))) INTO partidaNormal;

        -- points from partida multijogador
        SELECT pontuacao FROM partida_multijogador WHERE (nr_partida == (
        SELECT partida.nr FROM partida WHERE (
        SELECT joga.nr_partida FROM joga WHERE (joga.id_jogador == jogador_id)))) INTO partidaMultiJogador;

        RETURN partidaNormal + partidaMultiJogador;
    end;
$$;

-- This procedure calculates and returns the total points obtained by a player given their player ID. It is an
-- abstraction with transaction control and it performs the following tasks:
--
-- Sets the transaction isolation level to READ COMMITED because the functionality is read only.
-- Calls the totalPontosJogador function.
-- If the totalPontosJogador function raises a unique_violation exception, it raises a notice indicating that the
-- player is banned or inactive and rolls back the transaction.
-- Example usage:
-- CALL totalPontosJogadorTransaction(1);
CREATE PROCEDURE totalPontosJogadorTransaction(jogador_id INT)
    LANGUAGE plpgsql
AS
$$
    Declare t1 text;
            t2 text;
            t3 text;
            t4 text;
            t5 text;
    BEGIN
        SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
        SELECT totalPontosJogador(jogador_id);
    EXCEPTION
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS t1 = MESSAGE_TEXT,
                                    t2 = RETURNED_SQLSTATE,
                                    t3 = PG_EXCEPTION_DETAIL,
                                    t4 = PG_EXCEPTION_HINT,
                                    t5 = PG_EXCEPTION_CONTEXT;
            RAISE NOTICE 'MESSAGE_TEXT: %', t1;
            RAISE NOTICE 'SQLSTATE: %', t2;
            RAISE NOTICE 'DETAIL: %', t3;
            RAISE NOTICE 'HINT: %', t4;
            RAISE NOTICE 'CONTEXT: %', t5;
            ROLLBACK;
    END;
$$;

------------------------------------------------------------------------------------------------------------------------
-- (f) Criar a função totalJogosJogador que recebe como parâmetro o identificador de um jogador e devolve o número total
-- de jogos diferentes nos quais o jogador participou.

--- This function calculates and returns the total number of games a player has participated in given their player ID.
-- It performs the following tasks:
--
-- Checks if the given player ID exists in the jogador table. If not, it raises a notice indicating that the player was
-- not found.
-- Checks if the player is banned or inactive. If so, it raises a notice indicating that the player is banned or
-- inactive.
-- Checks if the player has played any games. If not, it raises a notice indicating that the player has not played any
-- games.
-- Retrieves the number of games from the partida_normal and partida_multijogador tables for the player ID.
-- Returns the sum of the number of games from both tables as the total number of games for the player.
-- Example usage:
-- SELECT totalJogosJogador(1);
CREATE FUNCTION totalJogosJogador(jogador_id INT)
    RETURNS INT
    LANGUAGE plpgsql
AS
$$
    DECLARE
        jogosNormal       INT;
        jogosMultiJogador INT;
    BEGIN
        -- Checks
        IF(jogador_id NOT IN (SELECT jogador.id FROM jogador)) THEN
            RAISE EXCEPTION 'Jogador with id (%) not found', jogador_id
                    USING HINT = 'Check the inserted id';
        END IF;
        IF ((SELECT jogador.estado FROM jogador WHERE jogador.id == jogador_id) == 'banido' | 'desativado') THEN
            RAISE NOTICE 'Jogador with id (%) is banned or inactive', jogador_id
                    USING HINT = 'Check the inserted id';
        END IF;
        IF ((SELECT joga.id_jogador FROM joga) <> jogador_id) THEN
            RAISE NOTICE 'Jogador with id (%) has not played any games', jogador_id
                    USING HINT = 'Check the inserted id or start a new game';
        END IF;
        -- expected
        -- counts the number of partidas normais
        SELECT count() INTO jogosNormal FROM partida_normal WHERE partida_normal.nr_partida == (
        SELECT partida.nr FROM partida WHERE (partida.nr == (
        SELECT joga.nr_partida FROM joga WHERE (joga.id_jogador == jogador_id))));

        -- counts the number of partidas multijogador
        SELECT count() INTO jogosMultiJogador FROM partida_multijogador WHERE partida_multijogador.nr_partida == (
        SELECT partida.nr FROM partida WHERE (partida.nr == (
        SELECT joga.nr_partida FROM joga WHERE (joga.id_jogador == jogador_id))));

        RETURN jogosNormal + jogosMultiJogador;
    END;
$$;

-- This procedure calculates and returns the total number of games a player has participated in given their player ID.
-- It is an abstraction with transaction control and it performs the following tasks:
--
-- Sets the transaction isolation level to READ COMMITED because the functionality is read only.
-- Calls the totalJogosJogador function.
-- If the totalJogosJogador function raises a unique_violation exception, it raises a notice indicating that the
-- player is banned or inactive and rolls back the transaction.
--
-- Example usage:
-- CALL totalJogosJogadorTransaction(1);
CREATE PROCEDURE totalJogosJogadorTransaction(jogador_id INT)
    LANGUAGE plpgsql
AS
$$
    Declare t1 text;
            t2 text;
            t3 text;
            t4 text;
            t5 text;
    BEGIN
        SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
        call totalJogosJogador(jogador_id);
    EXCEPTION
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS t1 = MESSAGE_TEXT,
                                    t2 = RETURNED_SQLSTATE,
                                    t3 = PG_EXCEPTION_DETAIL,
                                    t4 = PG_EXCEPTION_HINT,
                                    t5 = PG_EXCEPTION_CONTEXT;
            RAISE NOTICE 'MESSAGE_TEXT: %', t1;
            RAISE NOTICE 'SQLSTATE: %', t2;
            RAISE NOTICE 'DETAIL: %', t3;
            RAISE NOTICE 'HINT: %', t4;
            RAISE NOTICE 'CONTEXT: %', t5;
            ROLLBACK;
    END;
$$;

------------------------------------------------------------------------------------------------------------------------
-- (g) Criar a função PontosJogoPorJogador que recebe como parâmetro a referência de um jogo e devolve uma tabela com
-- duas colunas (identificador de jogador, total de pontos) em que cada linha contém o identificador de um jogador e o
-- total de pontos que esse jogador teve nesse jogo. Apenas devem ser devolvidos os jogadores que tenham jogado o jogo.

-- This function calculates and returns the total points obtained by each player in a game given the game ID. It
-- performs the following tasks:
--
-- Example usage:
-- SELECT * FROM PontosJogoPorJogador('1');
CREATE FUNCTION PontosJogoPorJogador(jogo_id ALPHANUMERIC)
    RETURNS TABLE (id_jogador INT, total_pontos INT)
    LANGUAGE plpgsql
AS
$$
    BEGIN
        IF (jogo_id NOT IN (SELECT jogo.id FROM jogo)) THEN
            RAISE EXCEPTION 'Jogo with id (%) not found', jogo_id
                    USING HINT = 'Check the inserted id';
        END IF;
        RETURN QUERY SELECT joga.id_jogador, totalPontosJogador(joga.id_jogador) FROM joga WHERE joga.id_jogador IN (
        SELECT joga.id_jogador FROM joga WHERE joga.nr_partida IN (
        SELECT partida.nr FROM partida WHERE partida.id_jogo == jogo_id));
    END;
$$;

-- This procedure calculates and returns the total points obtained by each player in a game given the game ID. It
-- performs the following tasks:
--
-- Sets the transaction isolation level to READ COMMITED because the functionality is read only.
-- Calls the PontosJogoPorJogador function.
-- If the PontosJogoPorJogador function raises a unique_violation exception, it raises a notice indicating that the
-- game does not exist and rolls back the transaction.
--
-- Example usage:
-- CALL PontosJogoPorJogadorTransaction('1');
CREATE PROCEDURE PontosJogoPorJogadorTransaction(jogo_id ALPHANUMERIC)
    LANGUAGE plpgsql
AS
$$
    Declare t1 text;
            t2 text;
            t3 text;
            t4 text;
            t5 text;
    BEGIN
        SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
        SELECT PontosJogoPorJogador(jogo_id);
    EXCEPTION
        WHEN no_data_found THEN
            RAISE NOTICE 'No players have played game with id (%)', jogo_id
                USING HINT = 'Start a new game';
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS t1 = MESSAGE_TEXT,
                                    t2 = RETURNED_SQLSTATE,
                                    t3 = PG_EXCEPTION_DETAIL,
                                    t4 = PG_EXCEPTION_HINT,
                                    t5 = PG_EXCEPTION_CONTEXT;
            RAISE NOTICE 'MESSAGE_TEXT: %', t1;
            RAISE NOTICE 'SQLSTATE: %', t2;
            RAISE NOTICE 'DETAIL: %', t3;
            RAISE NOTICE 'HINT: %', t4;
            RAISE NOTICE 'CONTEXT: %', t5;
            ROLLBACK;
    END;
$$;

------------------------------------------------------------------------------------------------------------------------
-- (h) Criar o procedimento armazenado associarCrachá que recebe como parâmetros o identificador de um jogador, a
-- referência de um jogo e o nome de um crachá desse jogo e atribui o crachá a esse jogador se ele reunir as condições
-- para o obter.

-- This procedure associates a crachá with a player if they meet the conditions to obtain it.
--
-- Example usage:
-- CALL associarCracha(1, '1', 'Crachá de Ouro');
CREATE PROCEDURE associarCracha(jogador_id INT, jogo_id ALPHANUMERIC, cracha_nome VARCHAR(50))
    LANGUAGE plpgsql
AS
$$
    DECLARE
        nome_cracha VARCHAR(50);
        total_pontos INT;
    BEGIN
        SELECT nome INTO nome_cracha FROM cracha WHERE cracha.nome == cracha_nome;
        SELECT total_pontos FROM PontosJogoPorJogador(jogo_id) AS pontos_jogo WHERE pontos_jogo.id_jogador = jogador_id INTO total_pontos;
        IF (total_pontos >= (SELECT limite_pontos FROM cracha WHERE cracha.nome == cracha_nome)) THEN
            INSERT INTO ganha VALUES (jogador_id, cracha_nome, jogo_id);
        END IF;
    END;
$$;

------------------------------------------------------------------------------------------------------------------------
-- (i) Criar o procedimento armazenado iniciarConversa que permite iniciar uma conversa (chat) dados o identificador de
-- um jogador e o nome da conversa. O jogador deve ficar automaticamente associado à conversa e deve ser criada uma
-- mensagem a informar que o jogador criou a conversa. O procedimento deve devolver num parâmetro de saída o
-- identificador da conversa criada.

-- This procedure starts a chat given the player ID and the name of the chat. The player is automatically associated
-- with the chat and a message is created informing that the player created the chat. The procedure returns the chat
-- ID in an output parameter.
--
-- Example usage:
-- CALL iniciarConversa(1, 'Chat 1', conversa_id);
CREATE PROCEDURE iniciarConversa(jogador_id INT, nome_conversa VARCHAR(50), conversa_id OUT INT)
    LANGUAGE plpgsql
AS
$$
    DECLARE
        default_conversa_nr_ordem INT := 1;
        nome_conversa VARCHAR(50);
    BEGIN
        SELECT nome INTO nome_conversa FROM conversa WHERE conversa.nome == nome_conversa;
        IF (nome_conversa == NULL) THEN
            INSERT INTO conversa VALUES (nome_conversa);
            SELECT id INTO conversa_id FROM conversa WHERE conversa.nome == nome_conversa;
            INSERT INTO participa VALUES (jogador_id, conversa_id);
            INSERT INTO mensagem VALUES (default_conversa_nr_ordem, 'O jogador criou a conversa', now(),
                                         jogador_id, conversa_id);
        END IF;
    END;
$$;

------------------------------------------------------------------------------------------------------------------------
-- (j) Criar o procedimento armazenado juntarConversa que recebe como parâmetros os identificadores de um jogador e de
-- uma conversa e junta esse jogador a essa conversa. Deve ser criada uma mensagem a informar que o jogador entrou na
-- conversa.

-- This procedure joins a player to a chat given the player ID and the chat ID. A message is created informing that
-- the player joined the chat.
--
-- Example usage:
-- CALL juntarConversa(1, 1);
CREATE PROCEDURE juntarConversa(jogador_id INT, conversa_id INT)
    LANGUAGE plpgsql
AS
$$
    DECLARE
        nr INT;
    BEGIN
        SELECT COUNT(mensagem.nr_ordem) INTO nr FROM mensagem WHERE id_jogador == jogador_id AND mensagem.id_conversa == conversa_id;
        INSERT INTO participa VALUES (jogador_id, conversa_id);
        INSERT INTO mensagem VALUES (nr, 'O jogador entrou na conversa', now(), jogador_id, conversa_id);
    END;
$$;

------------------------------------------------------------------------------------------------------------------------
-- (k) Criar o procedimento armazenado enviarMensagem que recebe como parâmetros os identificadores de um jogador e de
-- uma conversa e o texto de uma mensagem e procede ao envio dessa mensagem para a conversa indicada, associando-a ao
-- jogador também indicado.

-- This procedure sends a message to a chat given the player ID, the chat ID and the message text. The message is
-- associated with the player and the chat.
--
-- Example usage:
-- CALL enviarMensagem(1, 1, 'Mensagem 1');
CREATE PROCEDURE enviarMensagem(jogador_id INT, conversa_id INT, mensagem_texto VARCHAR(50))
    LANGUAGE plpgsql
AS
$$
    DECLARE
        nr INT;
    BEGIN
        --checks
        IF (jogador_id NOT IN (SELECT jogador.id FROM jogador)) THEN
            RAISE EXCEPTION 'O jogador com o id (%) não existe', jogador_id;
        END IF;
        IF (conversa_id NOT IN (SELECT conversa.id FROM conversa)) THEN
            RAISE EXCEPTION 'A conversa com o id (%) não existe', conversa_id;
        END IF;
        IF (mensagem_texto == NULL) THEN
            RAISE EXCEPTION 'A mensagem (%) não tem conteúdo', mensagem_texto;
        END IF;
        --expected
        IF (jogador_id NOT IN (SELECT id_jogador FROM participa WHERE participa.id_conversa == conversa_id)) THEN
            INSERT INTO participa VALUES (jogador_id, conversa_id);
        END IF;
        SELECT COUNT(mensagem.nr_ordem) INTO nr FROM mensagem WHERE id_jogador == jogador_id AND mensagem.id_conversa == conversa_id;
        INSERT INTO mensagem VALUES (nr, mensagem_texto, now(), jogador_id, conversa_id);
    END;
$$;

------------------------------------------------------------------------------------------------------------------------
-- (l) Criar a vista jogadorTotalInfo que permita aceder à informação sobre identificador, estado, email, username,
-- número total de jogos em que participou, número total de partidas em que participou e número total de pontos que já
-- obteve de todos os jogadores cujo estado seja diferente de “Banido”. Deve implementar na vista os cálculos sem aceder
-- às tabelas de estatísticas.

-- This function returns the total number of matches a player has played given the player ID.
--
-- Example usage:
-- SELECT totalPartidasJogador(1);
CREATE FUNCTION totalPartidasJogador(jogador_id INT)
    RETURNS INT
    LANGUAGE plpgsql
AS
$$
    DECLARE
        nr_partidas INT;
    BEGIN
        IF (jogador_id NOT IN (SELECT jogador.id FROM jogador)) THEN
            RAISE EXCEPTION 'Player with id (%) not found', jogador_id
                    USING HINT = 'Check the inserted id';
        END IF;
        IF (SELECT jogador.estado FROM jogador WHERE jogador.id == jogador_id) == 'Banido' THEN
            RAISE EXCEPTION 'Player with id (%) is banned', jogador_id
                    USING HINT = 'Check the inserted id';
        END IF;
        IF (jogador_id <> (SELECT joga.id_jogador FROM joga)) THEN
            RAISE NOTICE 'Player with id (%) has not played any matches', jogador_id
                    USING HINT = 'Check the inserted id';
            RETURN 0;
        END IF;
        SELECT COUNT(nr_partida) INTO nr_partidas FROM joga WHERE joga.id_jogador == jogador_id;
        RETURN nr_partidas;
    END;
$$;

-- This procedure returns the total number of matches a player has played given the player ID. It performs the
-- following tasks:
--
-- Sets the transaction isolation level to READ COMMITED because the functionality is read only.
-- Calls the totalPartidasJogador function.
-- If the totalPartidasJogador function raises a unique_violation exception, it raises a notice indicating that the
-- player does not exist and rolls back the transaction.
--
-- Example usage:
-- CALL totalPartidasJogadorTransaction(1);
CREATE PROCEDURE totalPartidasJogadorTransaction(jogador_id INT)
    LANGUAGE plpgsql
AS
$$
    Declare t1 text;
            t2 text;
            t3 text;
            t4 text;
            t5 text;
    BEGIN
        SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
        SELECT totalPartidasJogador(jogador_id);
    EXCEPTION
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS t1 = MESSAGE_TEXT,
                                    t2 = RETURNED_SQLSTATE,
                                    t3 = PG_EXCEPTION_DETAIL,
                                    t4 = PG_EXCEPTION_HINT,
                                    t5 = PG_EXCEPTION_CONTEXT;
            RAISE NOTICE 'MESSAGE_TEXT: %', t1;
            RAISE NOTICE 'SQLSTATE: %', t2;
            RAISE NOTICE 'DETAIL: %', t3;
            RAISE NOTICE 'HINT: %', t4;
            RAISE NOTICE 'CONTEXT: %', t5;
            ROLLBACK;
    END;
$$;

-- This view returns information about the ID, state, email, username, total number of games the player has played,
-- total number of matches the player has played and total number of points the player has obtained from all players
-- whose state is different from "Banido". It implements the calculations without accessing the statistics tables.
--
-- Example usage:
-- SELECT * FROM jogadorTotalInfo;
CREATE VIEW jogadorTotalInfo AS
    SELECT  jogador.id,
            jogador.estado,
            jogador.email,
            jogador.username,
            totalJogosJogador(jogador.id) AS total_jogos,
            totalPartidasJogador(jogador.id) AS total_partidas,
            totalPontosJogador(jogador.id) AS total_pontos
    FROM jogador WHERE jogador.estado != 'Banido';

------------------------------------------------------------------------------------------------------------------------
-- (m) Criar os mecanismos necessários para que, de forma automática, quando uma partida termina, se proceda à
-- atribuição de crachás do jogo a que ela pertence.

-- This function is called when a match ends and it assigns badges to the players who have played the match.
--
-- Example usage:
--
CREATE FUNCTION atribuirCrachas()
    RETURNS trigger
    LANGUAGE plpgsql
AS
$$
    DECLARE
        jogo_id      ALPHANUMERIC;
        jogador_id   INT;
        nome_cracha  VARCHAR(50);
        total_pontos INT;
    BEGIN
        SELECT jogo_id INTO jogo_id FROM partida WHERE partida.nr == NEW.nr;
        SELECT id_jogador INTO jogador_id FROM joga WHERE joga.nr_partida == NEW.nr;
        SELECT nome INTO nome_cracha FROM cracha WHERE cracha.id_jogo == jogo_id;
        SELECT pontuacao from partida_normal WHERE partida_normal.nr_partida == NEW.nr INTO total_pontos;
        IF (total_pontos == NULL) THEN
            SELECT pontuacao from partida_multijogador WHERE partida_multijogador.nr_partida == NEW.nr INTO total_pontos;
        END IF;
        IF (total_pontos >= (SELECT limite_pontos FROM cracha WHERE cracha.nome == nome_cracha)) THEN
            INSERT INTO ganha VALUES (jogador_id, nome_cracha, id_jogo);
        END IF;
    END;
$$;

-- This trigger is called when a match ends and it assigns badges to the players who have played the match if they
-- have obtained enough points.
CREATE TRIGGER atribuirCrachas
    AFTER INSERT ON partida
    FOR EACH ROW
    EXECUTE PROCEDURE atribuirCrachas();

------------------------------------------------------------------------------------------------------------------------
-- (n) Criar os mecanismos necessários para que a execução da instrução DELETE sobre a vista jogadorTotalInfo permita
-- colocar os jogadores envolvidos no estado “Banido”.

-- This function is called when a player is deleted from the view jogadorTotalInfo and it puts the player in the
-- "Banido" state.
--
-- Example usage:
-- DELETE FROM jogadorTotalInfo WHERE jogadorTotalInfo.username == 'jogador1';
CREATE FUNCTION banirJogador()
    RETURNS trigger
    LANGUAGE plpgsql
AS
$$
    BEGIN
        IF (OLD.id NOT IN (SELECT jogador.id FROM jogador)) THEN
            RAISE EXCEPTION 'Player with id (%) not found', OLD.id
                    USING HINT = 'Check Player ID';
        END IF;
        IF (OLD.estado == 'Banido') THEN
            RAISE EXCEPTION 'Player with id (%) is already banned', OLD.id
                    USING HINT = 'Check Player ID';
        END IF;
        UPDATE jogador SET estado = 'Banido' WHERE jogador.id == OLD.id;
    END;
$$;

-- This trigger is called when a player is deleted from the view jogadorTotalInfo and it puts the player in the
-- "Banido" state.
CREATE TRIGGER banirJogador
    INSTEAD OF DELETE ON jogadorTotalInfo
    FOR EACH ROW
    EXECUTE FUNCTION banirJogador();

COMMIT TRANSACTION;